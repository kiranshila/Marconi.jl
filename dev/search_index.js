var documenterSearchIndex = {"docs":
[{"location":"man/RFAnalysis/#RF-Analysis-1","page":"RF Analysis","title":"RF Analysis","text":"","category":"section"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"Pages = [\"RFAnalysis.md\"]\nDepth = 3","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"cd(\"../../..\") # hide\ncp(\"examples/CE3520K3.s2p\",\"docs/build/man/CE3520K3.s2p\", force = true) # hide\ncp(\"examples/BPF.s2p\",\"docs/build/man/BPF.s2p\", force = true) # hide\nnothing","category":"page"},{"location":"man/RFAnalysis/#The-Network-Object-1","page":"RF Analysis","title":"The Network Object","text":"","category":"section"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"Marconi is structured around a base AbstractNetwork object. This object can be constructed with data, equations, and the combination of other networks.","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"All networks provide attributes ports and Z0 for characteristic impedance.","category":"page"},{"location":"man/RFAnalysis/#DataNetwork-1","page":"RF Analysis","title":"DataNetwork","text":"","category":"section"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"To build a network from a Touchstone file see File IO, otherwise we can simply use the constructor for DataNetwork.","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"Besides ports and Z0, a DataNetwork must also have frequency, a vector of frequencies for which the network is characterized, and s_params, for the S-Parameters themselves.","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"As of this release, the frequency/s_params lists must be ordered. If they are not evenly-spaced, all interpolation operations will be Grid interpolations instead of splines.","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"using Marconi # hide\n# DataNetwork(ports,Z0,frequency,s_params)\nmyNetwork = DataNetwork(1,50,[100e6, 200e6],[0.3+0.5im, 0.4+0.6im])","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"For more than 1 port, the S-Parameters have to be an n-square matrix for n ports.","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"using Marconi # hide\nmyNetwork = DataNetwork(2,50,[100e6, 200e6],[[0.3+0.5im 0.1+0.2im; 0.4+0.6im 0.3+0.5im], [0.3+0.5im 0.1+0.2im; 0.4+0.6im 0.3+0.5im]])","category":"page"},{"location":"man/RFAnalysis/#EquationNetwork-1","page":"RF Analysis","title":"EquationNetwork","text":"","category":"section"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"To build a network from an equation, we start with an equation that defines some S-Parameters.","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"Take a series R-L network for example. The S-Parameters of an RL network would look like:","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"using Marconi # hide\nfunction inductorAndResistor(;freq,Z0)\n    L = 1e-9\n    R = 30\n    z = R + im*2*pi*freq*L\n    return (z-Z0)/(z+Z0)\nend","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"To use an equation-driven network in Marconi, the function must accept the kwags freq and Z0.","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"To build the EquationNetwork:","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"RL = EquationNetwork(1,50,inductorAndResistor)","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"Once again, for n-port networks, the function must provide an n-square matrix","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"function idealTransmissionLine(;freq,Z0)\n    l = 1e-2 # 2cm\n    λ = (3e8/freq)\n    β = (2*pi)/λ\n    return [0 exp(-β*l);exp(-β*l) 0]\nend\n\ntline = EquationNetwork(2,50,idealTransmissionLine)","category":"page"},{"location":"man/RFAnalysis/#Stability-Analysis-1","page":"RF Analysis","title":"Stability Analysis","text":"","category":"section"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"One of the most important aspects in active microwave design is that of stability.","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"When designing an amplifier, we do not want oscillations on either of the ports. An oscillation would imply that Gamma_In  1 or Gamma_Out  1.","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"As both of these gammas depend on the input and output matching networks, the stability of an amplifier depends on Gamma_S and Gamma_L.","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"There are two different kinds of stability:","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"Unconditional Stability - Gamma_In  1 and Gamma_Out  1 for all source and load impedances\nConditional Stability - Gamma_In  1 and Gamma_Out  1 for certain impedances.","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"To test for unconditional stability, we can use the Rollet Stability Criterion","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"K = frac1-S_11^2-S_22^2+Delta^22S_12S_21  1","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"along with the auxiliary condition that","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"Delta = S_11S_22-S_12S_21  1","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"For a device to be unconditionally stable, both of these conditions must be satisfied.","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"Alternatively, the μ stability parameter is a similar test for unconditional stability that integrates all conditions into a single parameter.","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"μ = frac1-S_11^2S_22-Delta S_11^* + S_12S_21  1","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"To test these conditions (or plot them), use the following functions:","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"using Marconi\nusing PGFPlotsX","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"Example 12.2 from Microwave Engineering by David M. Pozar","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"gan_hemt = [0.869*exp(deg2rad(-159)im) 4.250*exp(deg2rad(61)im);0.031*exp(deg2rad(-9)im) 0.507*exp(deg2rad(-117)im)]\n\nnetwork = DataNetwork(2,50,[1.9e9],[gan_hemt])","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"We now compute |Δ| with","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"testMagDelta(network)[1] # Only 1 point in this data","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"and K with","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"testK(network)[1]","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"So, now we can conclude that this device is NOT unconditionally stable at 1.9 GHz as Delta  1 but K1.","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"By calculating μ and testing the mu  1 stability condition a similar conclusion can be reached.","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"testμ(network)[1]","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"We can also plot the stability factors as a function of frequency to find stable regions.","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"Take the data from this CE3520K3 low noise JFET:","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"jfet = readTouchstone(\"CE3520K3.s2p\")\n\n# Plot our criteria\nax = plotRectangular(jfet,testK,label=\"K\")\nplotRectangular!(ax,jfet,testMagDelta,label=raw\"$|\\Delta|$\")\n\n# Add a horizontal line to show stability regions\npush!(ax,@pgf(HLine(@pgf({\"dashed\"}),1)))\n\n# Adjust legend location\nax[\"legend pos\"] = \"outer north east\"\n\n# And a title, why not\nax[\"title\"] = \"Stability Tests\"\n\nax # hide","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"From this plot, we can conclude that under 50Ω matching on both ports, this device is unconditionally stable from 14-18 GHz and above 25 GHz as those two regions satisfy the criterion.","category":"page"},{"location":"man/RFAnalysis/#Stability-Circles-1","page":"RF Analysis","title":"Stability Circles","text":"","category":"section"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"To observe the behavior of potentially unstable devices, we can plot the region that would push the device into oscillation. The circle that bounds these impedances are Stability Circles.","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"To plot these stability circles we can start with a network at one frequency:","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"LNA = DataNetwork(2,50,[800e6],[[∠(0.65,-95) ∠(0.035,40); ∠(5,115) ∠(0.8,-35)]])","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"Now we can plot the the source and load stability circles on a smith chart.","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"sc = SmithChart()\nplotSStabCircle!(sc,LNA,800e6,label=\"Source Stability\")\nplotLStabCircle!(sc,LNA,800e6,label=\"Load Stability\")","category":"page"},{"location":"man/RFAnalysis/#VSWR-Circles-1","page":"RF Analysis","title":"VSWR Circles","text":"","category":"section"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"Some times it is helpful to draw VSWR circles to know the bandwidth of a network. This is done with","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"using Marconi\nusing PGFPlotsX","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"# 10 dB RL == 1.92 VSWR\ncircleStyle = @pgf {\"thick\", color = \"black\"}\nbpf = readTouchstone(\"BPF.s2p\")\nsc = plotSmithData(bpf,(1,1),label=\"S(1,1)\")\nplotVSWR!(sc,1.92,opts = circleStyle,label=\"VSWR = 1.92\")","category":"page"},{"location":"man/RFAnalysis/#Gain-Equations-1","page":"RF Analysis","title":"Gain Equations","text":"","category":"section"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"These functions provide calculations to asses the gain performance of active microwave circuits","category":"page"},{"location":"man/RFAnalysis/#Maximum-Unilateral-Gain-1","page":"RF Analysis","title":"Maximum Unilateral Gain","text":"","category":"section"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"Making the unilateral assumption, S12 = 0, we can calculate MUG as","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"MUG = frac S_21^2  (1 - S_11^2)(1 - S_22^2) ","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"jfet = readTouchstone(\"CE3520K3.s2p\")\nplotRectangular(jfet,testMUG,dB,label=\"MUG\")","category":"page"},{"location":"man/RFAnalysis/#Maximum-Stable-Gain-1","page":"RF Analysis","title":"Maximum Stable Gain","text":"","category":"section"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"The maximum gain out of a potentially unstable device","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"MSG = frac S_21  S_12 ","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"jfet = readTouchstone(\"CE3520K3.s2p\")\nplotRectangular(jfet,testMSG,dB,label=\"MSG\")","category":"page"},{"location":"man/RFAnalysis/#Maximum-Available-Gain-1","page":"RF Analysis","title":"Maximum Available Gain","text":"","category":"section"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"Otherwise known as GMAX, MAG is the maximum gain from a stable network. This formula comes from Microwaves 101 - a modification from the textbook equation such that MAG behaves well for high K devices.","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"MAG = frac S_21  S_12  * frac1K+sqrtK^2-1","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"jfet = readTouchstone(\"CE3520K3.s2p\")\nplotRectangular(jfet,testMAG,dB,label=\"MAG\")","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"This makes sense as looking at the K plot from before, the device is only unconditionally stable around 14 GHz and above 25 GHz.","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"Just to compare this to the S21 parameter:","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"ax = plotRectangular(jfet,testMAG,dB,label=\"MAG\")\nplotRectangular!(ax,jfet,(2,1),label=\"S(2,1)\")","category":"page"},{"location":"man/RFAnalysis/#Transmission-Line-Calculations-1","page":"RF Analysis","title":"Transmission Line Calculations","text":"","category":"section"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"Marconi provides some basic calculations for transmission lines:","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"using Marconi","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"# Input impedance of lossless t-line terminated in Zr\nΘ = 35\nZr = 100+im*50\nZin = inputZ(Zr,Θ)","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"And to show the behavior we expect from a λ/4 line:","category":"page"},{"location":"man/RFAnalysis/#","page":"RF Analysis","title":"RF Analysis","text":"Θ = 89.99\nZr = 1e99+0im\nZin = inputZ(Zr,Θ)","category":"page"},{"location":"lib/Public/#Public-Functions-for-Marconi-1","page":"Public","title":"Public Functions for Marconi","text":"","category":"section"},{"location":"lib/Public/#Index-1","page":"Public","title":"Index","text":"","category":"section"},{"location":"lib/Public/#","page":"Public","title":"Public","text":"Pages = [\"Public.md\"]","category":"page"},{"location":"lib/Public/#Public-Interface-1","page":"Public","title":"Public Interface","text":"","category":"section"},{"location":"lib/Public/#","page":"Public","title":"Public","text":"Modules = [Marconi]\nOrder   = [:type, :function]","category":"page"},{"location":"lib/Public/#Marconi.ArrayFactor","page":"Public","title":"Marconi.ArrayFactor","text":"ArrayFactor\n\nStores the array factor due to N isotropic radiators located at locations with phasor excitations excitations. Calling an ArrayFactor object with the arguments ϕ,θ,and frequency will return in dB the value of the AF at that location in spherical coordinates.\n\n\n\n\n\n","category":"type"},{"location":"lib/Public/#Marconi.DataNetwork","page":"Public","title":"Marconi.DataNetwork","text":"The base Network type for representing n-port linear networks with characteristic impedance Z0.   By default, the network is stored as S-Parameters with the corresponding frequency list.\n\n\n\n\n\n","category":"type"},{"location":"lib/Public/#Marconi.EquationNetwork","page":"Public","title":"Marconi.EquationNetwork","text":"The base Network type for representing n-port linear networks with characteristic impedance Z0.   The S-Parameters for an EquationNetwork are defined by a function that returns a ports-square matrix   and accepts kwargs Z0 and freq. Please provide default arguments for any input parameters.\n\n\n\n\n\n","category":"type"},{"location":"lib/Public/#Marconi.RadiationPattern","page":"Public","title":"Marconi.RadiationPattern","text":"RadiationPattern\n\nStores a 3D antenna radiation pattern in spherical coordinates. Φ and Θ are in degrees, pattern is in dBi\n\n\n\n\n\n","category":"type"},{"location":"lib/Public/#Marconi.RadiationPattern-Tuple{ArrayFactor,Union{AbstractRange, Array},Union{AbstractRange, Array},Real}","page":"Public","title":"Marconi.RadiationPattern","text":"    RadiationPattern(AF,ϕ,θ,freq)\n\nConstructs a RadiationPattern from an ArrayFactor sampled in ϕ and θ at freq\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Base.:+-Tuple{RadiationPattern,RadiationPattern}","page":"Public","title":"Base.:+","text":"    +(Pattern1,Pattern2)\n\nAdds two patterns of equal size together. Useful for arrays\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.applyAF-Tuple{Any,Any,Any}","page":"Public","title":"Marconi.applyAF","text":"    applyAF(pattern,AF,freq)\n\nApplys an ArrayFactor to a RadiationPattern.\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.cascade-Tuple{Vararg{AbstractNetwork,N} where N}","page":"Public","title":"Marconi.cascade","text":"cascade(net1,net2,net3,...,netN)\n\nReturns a new DataNetwork that is the cascaded result of net1,net2,net3,...netN where the nets are a mixture of 2-Port DataNetwork objects and 2-Port EquaionNetwork object. Optionally takes kwarg numpoints for how many points in the result.\n\nSee the docs for details of dealing with equation-driven networks\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.cascade-Tuple{Vararg{DataNetwork,N} where N}","page":"Public","title":"Marconi.cascade","text":"cascade(net1,net2,net3,...,netN)\n\nReturns a new DataNetwork that is the cascaded result of net1,net2,net3,...netN where the nets are 2-Port DataNetwork objects. Optionally takes kwarg numpoints for how many points in the result.\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.cascade-Tuple{Vararg{EquationNetwork,N} where N}","page":"Public","title":"Marconi.cascade","text":"cascade(net1,net2,net3,...,netN)\n\nReturns a new EquationNetwork that is the cascaded result of net1,net2,net3,...netN where the nets are 2-Port EquationNetwork objects.\n\nSee the docs for details of dealing with equation-driven networks\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.equationToDataNetwork-Tuple{EquationNetwork}","page":"Public","title":"Marconi.equationToDataNetwork","text":"equationToDataNetwork(equationNet,args=(arg1,arg2),freqs=[1,2,3])\n\nUtility function to convert an equation network to a data network by evaluating it at every frequency in the list or range freqs.\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.generateCircularAF-NTuple{5,Any}","page":"Public","title":"Marconi.generateCircularAF","text":"    generateCircularAF(N,R,ϕ,θ,freq)\n\nCreates an ArrayFactor object from a circular array with N excitations in a circle with radius R. The excitations are phased such that the main beam is in the ϕ, θ, direction at frequency freq.\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.generateRectangularAF-NTuple{7,Any}","page":"Public","title":"Marconi.generateRectangularAF","text":"    generateRectangularAF(Nx,Ny,Spacingx,Spacingy,ϕ,θ,freq)\n\nCreates an ArrayFactor object from a rectangular array that is Nx X Ny big with spacing Spacingx and Spacingy. The excitations are phased such that the main beam is in the ϕ, θ, direction at frequency freq.\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.inputZ-Tuple{Any,Any}","page":"Public","title":"Marconi.inputZ","text":"inputZ(Zr,Θ,Z0)\n\nCalculates the input impedance of a lossless transmission line of length θ in degrees terminated with Zr. Z0 is optional and defaults to 50.\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.inputZ-Tuple{Any}","page":"Public","title":"Marconi.inputZ","text":"inputZ(Γ,Z0)\n\nCalculates the input impedace from complex reflection coefficient Γ. Z0 is optional and defaults to 50.\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.interpolate-Union{Tuple{T}, Tuple{DataNetwork,Array{T,1}}} where T<:Real","page":"Public","title":"Marconi.interpolate","text":"interpolate(network,frequencies)\n\nReturns a new network object that contains data from network reinterpolated to fit frequencies.\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.phaseLocations-NTuple{4,Any}","page":"Public","title":"Marconi.phaseLocations","text":"    phaseLocations(Locations,ϕ,θ,freq)\n\nGiven antennas at locations Locations which is a vector of 3-Tuples of cartesian coordinates, calculate the corresponding phases to steer the beam in ϕ and θ at frequency freq\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.plotLStabCircle!-Union{Tuple{T}, Tuple{SmithChart,T,Real}} where T<:AbstractNetwork","page":"Public","title":"Marconi.plotLStabCircle!","text":"plotLStabCircle!(sc,network,freq)\n\nPlots the the load stability circle on Smith Chart sc from network at frequency freq.\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.plotPattern2D-Tuple{RadiationPattern,Real}","page":"Public","title":"Marconi.plotPattern2D","text":"    plotPattern2D(pattern,ϕ)\n\nPlots the 2D Radiation Pattern of pattern at the phi cut ϕ. Optionally can set the minimum and maximum gain with kwargs gainMin and gainMax.\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.plotPattern3D-Tuple{RadiationPattern}","page":"Public","title":"Marconi.plotPattern3D","text":"    plotPattern3D(pattern,ϕ)\n\nPlots the 3D Radiation Pattern of pattern. Optionally can set the minimum and maximum gain with kwargs gainMin and gainMax.\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.plotSStabCircle!-Union{Tuple{T}, Tuple{SmithChart,T,Real}} where T<:AbstractNetwork","page":"Public","title":"Marconi.plotSStabCircle!","text":"plotSStabCircle!(sc,network,freq)\n\nPlots the the source stability circle on Smith Chart sc from network at frequency freq.\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.plotSmithCircle!-Union{Tuple{C}, Tuple{B}, Tuple{A}, Tuple{SmithChart,A,B,C}} where C<:Real where B<:Real where A<:Real","page":"Public","title":"Marconi.plotSmithCircle!","text":"plotSmithCircle!(sc, xc, yc, rad)\n\nPlots a cricle with center coordinates (xc,yc) on the Gamma plane with radius rad on an existing Smith Chart object.\n\nReturns the sc object\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.plotSmithData!-Union{Tuple{T}, Tuple{SmithChart,T,Tuple{Int64,Int64}}} where T<:AbstractNetwork","page":"Public","title":"Marconi.plotSmithData!","text":"plotSmithData!(sc, network,(1,1))\n\nPlots the S(1,1) parameter from network on an existing Smith Chart sc\n\nReturns the sc object\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.plotSmithData-Union{Tuple{T}, Tuple{T,Tuple{Int64,Int64}}} where T<:AbstractNetwork","page":"Public","title":"Marconi.plotSmithData","text":"plotSmithData(network,(1,1))\n\nPlots the S(1,1) parameter from network on a Smith Chart.\n\nReturns a PGFPlotsX.SmithChart object.\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.plotVSWR!-Tuple{SmithChart,Real}","page":"Public","title":"Marconi.plotVSWR!","text":"plotVSWR!(sc,VSWR)\n\nPlots the circle that represents a VSWR of VSWR onto an existing Smith Chart.\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.readHFSSPattern-Tuple{String}","page":"Public","title":"Marconi.readHFSSPattern","text":"    readHFSSPattern(\"myAntenna.csv\")\n\nReads the exported fields from HFSS into a Marconi RadiationPattern object.\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.readTouchstone-Tuple{String}","page":"Public","title":"Marconi.readTouchstone","text":"readTouchstone(\"myFile.sNp\")\n\nReads the contents of myFile.sNp into a Network object. This will convert all file types to S-Parameters, Real/Imaginary\n\nCurrently does not support reference lines (Different port impedances) or noise parameters\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.s2t-Union{Tuple{Array{T,2}}, Tuple{T}} where T<:Number","page":"Public","title":"Marconi.s2t","text":"    s2t(s)\n\nConverts S-Parameters s to T-Parameters.\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.s2y-Union{Tuple{Array{A,2}}, Tuple{B}, Tuple{A}} where B<:Number where A<:Number","page":"Public","title":"Marconi.s2y","text":"    s2y(s)\n\nConverts S-Parameters s to Y-Parameters. Optionally include reference impedance with kwarg Z0 with s2z(s,Z0=50).\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.s2z-Union{Tuple{Array{A,2}}, Tuple{B}, Tuple{A}} where B<:Number where A<:Number","page":"Public","title":"Marconi.s2z","text":"    s2z(s)\n\nConverts S-Parameters s to Z-Parameters. Optionally include reference impedance with kwarg Z0 with s2z(s,Z0=50).\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.t2s-Union{Tuple{Array{T,2}}, Tuple{T}} where T<:Number","page":"Public","title":"Marconi.t2s","text":"    t2s(t)\n\nConverts T-Parameters t to S-Parameters.\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.testDelta-Union{Tuple{T}, Tuple{T}} where T<:DataNetwork","page":"Public","title":"Marconi.testDelta","text":"testDelta(network)\n\nReturns a vector of Δ, the determinant of the scattering matrix. Optionally, returns Δ for S-Parameters at position pos.\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.testK-Union{Tuple{T}, Tuple{T}} where T<:DataNetwork","page":"Public","title":"Marconi.testK","text":"testK(network)\n\nReturns a vector of the magnitude of K, the Rollet stability factor.\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.testMAG-Tuple{DataNetwork}","page":"Public","title":"Marconi.testMAG","text":"testMAG(network)\n\nReturns a vector of the maximum available gain of a network.\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.testMSG-Tuple{DataNetwork}","page":"Public","title":"Marconi.testMSG","text":"testMSG(network)\n\nReturns a vector of the maximum stable gain of a network.\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.testMUG-Tuple{DataNetwork}","page":"Public","title":"Marconi.testMUG","text":"testMUG(network)\n\nReturns a vector of the maximum unilateral gain of a network.\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.testMagDelta-Union{Tuple{T}, Tuple{T}} where T<:DataNetwork","page":"Public","title":"Marconi.testMagDelta","text":"testMagDelta(network)\n\nReturns a vector of |Δ|, the magnitude of the determinant of the scattering matrix. Optionally, returns |Δ| for S-Parameters at position pos.\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.writeTouchstone-Tuple{AbstractNetwork,String}","page":"Public","title":"Marconi.writeTouchstone","text":"writeTouchstone(network,filename)\n\nWrites a Touchstone file from a Marconi network.\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.y2s-Union{Tuple{Array{A,2}}, Tuple{B}, Tuple{A}} where B<:Number where A<:Number","page":"Public","title":"Marconi.y2s","text":"    y2s(y)\n\nConverts Y-Parameters y to S-Parameters. Optionally include reference impedance with kwarg Z0 with y2s(y,Z0=50).\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.y2t-Union{Tuple{Array{A,2}}, Tuple{B}, Tuple{A}} where B<:Number where A<:Number","page":"Public","title":"Marconi.y2t","text":"    y2t(y)\n\nConverts Y-Parameters y to T-Parameters. Optionally include reference impedance with kwarg Z0 with y2s(y,Z0=50).\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.y2z-Union{Tuple{Array{A,2}}, Tuple{A}} where A<:Number","page":"Public","title":"Marconi.y2z","text":"    y2z(y)\n\nConverts Y-Parameters y to Z-Parameters.\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.z2s-Union{Tuple{Array{A,2}}, Tuple{B}, Tuple{A}} where B<:Number where A<:Number","page":"Public","title":"Marconi.z2s","text":"    z2s(z)\n\nConverts Z-Parameters z to S-Parameters. Optionally include reference impedance with kwarg Z0 with z2s(z,Z0=50).\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.z2t-Union{Tuple{Array{A,2}}, Tuple{B}, Tuple{A}} where B<:Number where A<:Number","page":"Public","title":"Marconi.z2t","text":"    z2t(z)\n\nConverts Z-Parameters z to T-Parameters. Optionally include reference impedance with kwarg Z0 with z2s(z,Z0=50).\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.z2y-Union{Tuple{Array{A,2}}, Tuple{A}} where A<:Number","page":"Public","title":"Marconi.z2y","text":"    z2y(z)\n\nConverts Z-Parameters z to Y-Parameters.\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.Γ-Tuple{Any}","page":"Public","title":"Marconi.Γ","text":"Γ(Z,Z0)\n\nCalculates the complex reflection coefficient Γ from impedance Z. Z0 is optional and defaults to 50.\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.∠-Tuple{Any,Any}","page":"Public","title":"Marconi.∠","text":"∠(mag,angle)\n\nA nice compact way of representing phasors. Angle is in degrees.\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.processTouchstoneLine-Union{Tuple{T}, Tuple{String,Real,paramType,paramFormat,T}} where T<:Number","page":"Public","title":"Marconi.processTouchstoneLine","text":"Internal function to process touchstone lines\n\n\n\n\n\n","category":"method"},{"location":"lib/Public/#Marconi.testμ-Union{Tuple{T}, Tuple{T}} where T<:DataNetwork","page":"Public","title":"Marconi.testμ","text":"testμ(network)\n\nReturns a vector of the magnitude of μ, the μ stability factor[1].\n\nDefinition\n\nThe network is unconditionally stable if μ > 1, for μ defined as: \n\nmu = frac1-S_11^2S_22-Delta S_11^* + S_12S_21\n\n[1]: M. L. Edwards and J. H. Sinsky, \"A new criterion for linear 2-port stability using a single geometrically derived parameter,\" in IEEE Transactions on Microwave Theory and Techniques, vol. 40, no. 12, pp. 2303-2311, Dec. 1992. doi: 10.1109/22.179894\n\n\n\n\n\n","category":"method"},{"location":"man/Antennas/#Antennas-1","page":"Antennas","title":"Antennas","text":"","category":"section"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"Pages = [\"Antennas.md\"]\nDepth = 3","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"cd(\"../../..\") # hide\ncp(\"examples/Pattern.csv\",\"docs/build/man/Pattern.csv\", force = true) # hide\nnothing","category":"page"},{"location":"man/Antennas/#The-Basics-1","page":"Antennas","title":"The Basics","text":"","category":"section"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"Marconi provides an object for storing and handling radiation pattern data as an interface to working with antennas. This library doesn't intend to ever replace a full-wave solver, but hopefully will provide functions to get started with designing basic antennas and arrays.","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"To try to provide some semblance of consistency, most everything involving antennas will be in the order of phi, theta. This includes the indexing into array data. These angles are in degrees for all of the functions in Marconi.","category":"page"},{"location":"man/Antennas/#Radiation-Patterns-1","page":"Antennas","title":"Radiation Patterns","text":"","category":"section"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"This RadiationPattern object can be constructed in a few ways. The default constructor accepts a range or array of azimuth from the x-axis - phi, the elevation towards -z from the z axis theta, and a 2D matrix of the pattern data represented by those spherical points. This data matrix is stored in dBi, or dB above isotropic.","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"To construct an isotropic radiator, for example:","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"using Marconi\n\nϕ = 0:360\nθ = 0:180\ndata = zeros(Float64,(length(ϕ),length(θ)))\n\nisotropic = RadiationPattern(ϕ,θ,data)","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"The patterns we can generate within Marconi are limited, so most of the pattern data will come from outside sources. Most of what I use this for is importing simulated data from HFSS. This format is a simple CSV file, following a ϕ,θ,gain format with phi swept first. One can bring in data from an antenna chamber with the same function, as long as the data is evenly sampled.","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"To read from a CSV file in this format, a la HFSS:","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"pattern = readHFSSPattern(\"Pattern.csv\")","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"Notice that this will automatically calculate the range of the pattern in ϕ and θ and create the range objects for you.","category":"page"},{"location":"man/Antennas/#Plotting-Radiation-Patterns-1","page":"Antennas","title":"Plotting Radiation Patterns","text":"","category":"section"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"We can plot these radiation patterns in 2D and 3D with the Plotly.js backend. These plots are fully interactive and the objects returned by these plot functions can be modified as typical PlotlyJS objects.","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"To plot a polar 2D plot, call the plotPattern2D function with the pattern and a ϕ to slice.","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"plt = plotPattern2D(pattern,90)\nhtml_plot(plt) # hide","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"And to plot in 3D, call the plotPattern3D function.","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"plt = plotPattern3D(pattern,gainMin = -30)\nhtml_plot(plt) # hide","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"Both of these functions utilize the gainMin and gainMax kwarg to set plotting bounds.","category":"page"},{"location":"man/Antennas/#Antenna-Arrays-and-Array-Factor-1","page":"Antennas","title":"Antenna Arrays and Array Factor","text":"","category":"section"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"Another very important aspect of working with antennas, is utilizing multiple antennas to form an array. The mechanics of arrays are quite simple, and the analysis of the math can be found in any introductory antenna theory book.","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"In short, an array can be analyzed by first looking at the Array Factor. The Array Factor is the \"Radiation Pattern\" of an array with isotropic antennas located at certain positions with certain phasor excitations. This is useful as it removes the element pattern from the analysis so one can just evaluate the performance of the spacing and phasing itself.","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"To construct an array, one can provide the locations and excitations directly into the ArrayFactor constructor.","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"using Marconi\nusing PlotlyJS","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"AF = ArrayFactor([(0,0,0),(1,1,1)],[∠(1,0),∠(1,35)])","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"This creates an array factor object for antennas located at (0,0,0) and (1,1,1) with excitations 1∠0 and 1∠35.","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"To evaluate the directivity of the Array Factor at a given spherical point, we perform the following calculation:","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"First we construct the steering vector","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"V = e^-jk cdot r","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"Where r is the vector to each antenna location, and k is the wave vector in spherical.","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"Given the vector of excitations, we simply dot the steering vector with the excitations to get linear directivity.","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"In Marconi, use the ArrayFactor functor to generate this at a given, ϕ and θ, and frequency freq.","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"D = AF(45,45,1e9)","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"To work with the AF as a pattern, we can evaluate this AF functor at every phi and theta in a list by using the RadiationPattern constructor for an ArrayFactor.","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"Pattern = RadiationPattern(AF,0:360,-180:180,1e9)","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"We can then plot this as if it were a regular RadiationPattern:","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"plt = plotPattern2D(Pattern,0,gainMin=-30)\nhtml_plot(plt) # hide","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"plt = plotPattern3D(Pattern,gainMin=-30)\nhtml_plot(plt) # hide","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"This is useful for general case arrays, but often we deal with rectangular arrays. A rectangular array can be created with the generateRectangularAF function. This requires a number of elements in x and y, the spacing in x and y (in meters), ϕ and θ for the direction of the beam (for a phased array), and a frequency to relate the phasing to the physical distance.","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"Lets create a broadside λ/2-spaced 4x4 square array for 5.8 GHz and plot it in 3D.","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"freq = 5.8e9\nλ = c₀/freq\nAF = generateRectangularAF(4,4,λ/2,λ/2,0,0,freq)\nPattern = RadiationPattern(AF,0:360,0:180,freq)\nplt = plotPattern3D(Pattern,gainMin=-30)\nhtml_plot(plt) # hide","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"As expected from theory, we get no grating lobes. We can easily investigate the effect of greater spacing, say λ.","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"AF = generateRectangularAF(4,4,λ,λ,0,0,freq)\nPattern = RadiationPattern(AF,0:360,0:180,freq)\nplt = plotPattern3D(Pattern,gainMin=-30)\nhtml_plot(plt) # hide","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"Once again, from theory, we now see grating lobes appear at θ=90. Now if we didn't want the array to be broadside, we can use the generateRectangularAF function to steer the array towards an arbitrary direction, say ϕ=45, θ=45.","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"AF = generateRectangularAF(4,4,λ/2,λ/2,45,45,freq)\nPattern = RadiationPattern(AF,0:360,0:180,freq)\nplt = plotPattern3D(Pattern,gainMin=-30)\nhtml_plot(plt) # hide","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"If we want a circular array with the same number of elements to point in the same direction, we can use the generateCircularAF function.","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"AF = generateCircularAF(16,λ,45,45,freq)\nPattern = RadiationPattern(AF,0:360,0:180,freq)\nplt = plotPattern3D(Pattern,gainMin=-30)\nhtml_plot(plt) # hide","category":"page"},{"location":"man/Antennas/#Applying-Array-Factors-to-Radiation-Pattern-Data-1","page":"Antennas","title":"Applying Array Factors to Radiation Pattern Data","text":"","category":"section"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"Analyzing the array factor by itself is useful as we can get insight into grating lobes, and some rudimentary gain analysis, but usually we want to investigate what our single element will look like in an array context.","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"The theory states that we can simply add the dBi array factor to our pattern measurement - assuming we feed the array with the excitations given in the array factor.","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"Marconi supplies a utility function to generate a RadiationPattern from the array factor with the same spherical steps as the pattern. Then it will add two patterns together and return a new RadiationPattern. Take the pattern from the beginning of this page for example. We can put it in a 2x2 array with 10mm spacing at 38 GHz, broadside phased.","category":"page"},{"location":"man/Antennas/#","page":"Antennas","title":"Antennas","text":"freq = 38e9\nPattern = readHFSSPattern(\"Pattern.csv\")\nAF = generateRectangularAF(2,2,10e-3,10e-3,0,0,freq)\nArrayPattern = applyAF(Pattern,AF,freq)\nplt = plotPattern3D(ArrayPattern,gainMin=-30)\nhtml_plot(plt) # hide","category":"page"},{"location":"man/Antennas/#Solving-Radiation-Patterns-1","page":"Antennas","title":"Solving Radiation Patterns","text":"","category":"section"},{"location":"man/Metamaterials/#Metamaterials-1","page":"Metamaterials","title":"Metamaterials","text":"","category":"section"},{"location":"man/Metamaterials/#","page":"Metamaterials","title":"Metamaterials","text":"Pages = [\"Metamaterials.md\"]\nDepth = 3","category":"page"},{"location":"man/Metamaterials/#Coming-Soon-1","page":"Metamaterials","title":"Coming Soon","text":"","category":"section"},{"location":"man/FileIO/#File-IO-1","page":"File IO","title":"File IO","text":"","category":"section"},{"location":"man/FileIO/#","page":"File IO","title":"File IO","text":"Pages = [\"FileIO.md\"]\nDepth = 3","category":"page"},{"location":"man/FileIO/#Reading-Touchstone-Files-1","page":"File IO","title":"Reading Touchstone Files","text":"","category":"section"},{"location":"man/FileIO/#","page":"File IO","title":"File IO","text":"One of the easiest ways to get measured data into Marconi is with Touchstone files.","category":"page"},{"location":"man/FileIO/#","page":"File IO","title":"File IO","text":"These files follow the standard enumerated here - a typical output format from simulation software and network analyzers.","category":"page"},{"location":"man/FileIO/#","page":"File IO","title":"File IO","text":"note: Note\nMarconi currently doesn't support port impedance mapping (different port impedances) or noise parameters.","category":"page"},{"location":"man/FileIO/#","page":"File IO","title":"File IO","text":"Reading these files into a Network object is straightforward","category":"page"},{"location":"man/FileIO/#","page":"File IO","title":"File IO","text":"cd(\"../../..\")\ncp(\"examples/BPF.s2p\",\"docs/build/man/BPF.s2p\",force = true)\ncp(\"examples/Amp.s2p\",\"docs/build/man/Amp.s2p\", force = true) # hide\ncp(\"examples/Short.s1p\",\"docs/build/man/Short.s1p\", force = true) # hide\nnothing","category":"page"},{"location":"man/FileIO/#","page":"File IO","title":"File IO","text":"using Marconi # hide\nreadTouchstone(\"BPF.s2p\")","category":"page"},{"location":"man/FileIO/#Writing-Touchstone-Files-1","page":"File IO","title":"Writing Touchstone Files","text":"","category":"section"},{"location":"man/FileIO/#","page":"File IO","title":"File IO","text":"To save your work from Marconi, one can either work directly with the frequency and s_params from a DataNetwork or save directly to a Touchstone file with writeTouchstone","category":"page"},{"location":"man/FileIO/#","page":"File IO","title":"File IO","text":"using Marconi # hide\namp = readTouchstone(\"Amp.s2p\")\nbpf = readTouchstone(\"BPF.s2p\")\nsystem = cascade(bpf,amp)\nwriteTouchstone(system,\"Cascade.s2p\")\nrm(\"Cascade.s2p\") # hide","category":"page"},{"location":"man/FileIO/#","page":"File IO","title":"File IO","text":"As of this version, Marconi will write the touchstone file in Hz with S-Parameters in Real/Imaginary format as every software should in theory support all versions of the format. Format specifiers could come in a future release.","category":"page"},{"location":"man/NetworkAnalysis/#Network-Analysis-1","page":"Network Analysis","title":"Network Analysis","text":"","category":"section"},{"location":"man/NetworkAnalysis/#","page":"Network Analysis","title":"Network Analysis","text":"Pages = [\"NetworkAnalysis.md\"]\nDepth = 3","category":"page"},{"location":"man/NetworkAnalysis/#Converting-Between-Networks-Representations-1","page":"Network Analysis","title":"Converting Between Networks Representations","text":"","category":"section"},{"location":"man/NetworkAnalysis/#","page":"Network Analysis","title":"Network Analysis","text":"Marconi provides functionality to convert between S,Z,Y, and T Parameters. See the library for more details.","category":"page"},{"location":"man/NetworkAnalysis/#Interpolations-1","page":"Network Analysis","title":"Interpolations","text":"","category":"section"},{"location":"man/NetworkAnalysis/#","page":"Network Analysis","title":"Network Analysis","text":"To interpolate networks, one can just call interpolate with a network object and some array or range of new frequencies. For evenly-spaced networks, interpolate will use a cubic spline interpolation, while uneven spaced networks will use a standard linear gridded interpolation.","category":"page"},{"location":"man/NetworkAnalysis/#","page":"Network Analysis","title":"Network Analysis","text":"cd(\"../../..\") # hide\ncp(\"examples/Amp.s2p\",\"docs/build/man/Amp.s2p\", force = true) # hide\ncp(\"examples/CE3520K3.s2p\",\"docs/build/man/CE3520K3.s2p\", force = true) # hide\nnothing","category":"page"},{"location":"man/NetworkAnalysis/#","page":"Network Analysis","title":"Network Analysis","text":"using Marconi\nusing PGFPlotsX","category":"page"},{"location":"man/NetworkAnalysis/#","page":"Network Analysis","title":"Network Analysis","text":"# Uneven network\namp = readTouchstone(\"Amp.s2p\")","category":"page"},{"location":"man/NetworkAnalysis/#","page":"Network Analysis","title":"Network Analysis","text":"This network has 879 points from 10 MHz to 18 GHz. Let's reinterpret it to more points.","category":"page"},{"location":"man/NetworkAnalysis/#","page":"Network Analysis","title":"Network Analysis","text":"amp_morePoints = interpolate(amp,range(10e6,stop=18e9,length=1001))","category":"page"},{"location":"man/NetworkAnalysis/#","page":"Network Analysis","title":"Network Analysis","text":"As typical with interpolations, one can only interpolate between the bounds of the source data.","category":"page"},{"location":"man/NetworkAnalysis/#Cascading-Networks-1","page":"Network Analysis","title":"Cascading Networks","text":"","category":"section"},{"location":"man/NetworkAnalysis/#","page":"Network Analysis","title":"Network Analysis","text":"For working with 2-Port networks, cascading multiple networks can be helpful for finding system performance, embedding, and deembedding.","category":"page"},{"location":"man/NetworkAnalysis/#","page":"Network Analysis","title":"Network Analysis","text":"cascade takes n number of 2-Port networks and returns a new DataNetwork that is the cascaded result of all the networks. This function interpolates all networks to their overlapping frequency range, converts to T-Parameters, and cascades with matrix multiplication.","category":"page"},{"location":"man/NetworkAnalysis/#","page":"Network Analysis","title":"Network Analysis","text":"using Marconi\nusing PGFPlotsX","category":"page"},{"location":"man/NetworkAnalysis/#","page":"Network Analysis","title":"Network Analysis","text":"Here are two networks individually, an amplifier and band-pass filter","category":"page"},{"location":"man/NetworkAnalysis/#","page":"Network Analysis","title":"Network Analysis","text":"amp = readTouchstone(\"Amp.s2p\")\nbpf = readTouchstone(\"BPF.s2p\")\nax = plotRectangular(amp,(2,1))\nplotRectangular!(ax,bpf,(2,1))","category":"page"},{"location":"man/NetworkAnalysis/#","page":"Network Analysis","title":"Network Analysis","text":"And cascading Port 1 -> BPF -> Amp -> Port 2","category":"page"},{"location":"man/NetworkAnalysis/#","page":"Network Analysis","title":"Network Analysis","text":"system = cascade(bpf,amp)\nplotRectangular!(ax,system,(2,1))","category":"page"},{"location":"man/NetworkAnalysis/#Cascading-Data-Networks-with-Equation-Driven-Networks-1","page":"Network Analysis","title":"Cascading Data Networks with Equation-Driven Networks","text":"","category":"section"},{"location":"man/NetworkAnalysis/#","page":"Network Analysis","title":"Network Analysis","text":"Working with both data networks and equation driven networks can be tricky as mixing the two will always product a DataNetwork","category":"page"},{"location":"man/NetworkAnalysis/#","page":"Network Analysis","title":"Network Analysis","text":"Cascading any amount of equation-driven networks with a data network will always return a DataNetwork. Just as before, the frequency of the result is the range that overlaps all the data networks or in the case of only one data network, the frequency range of that network.","category":"page"},{"location":"man/NetworkAnalysis/#","page":"Network Analysis","title":"Network Analysis","text":"function sillyFilter(f_center=1e9,rolloff=1;freq,Z0)\n    s21 = f_center / (abs(freq-f_center)+f_center)*rolloff\n    return [sqrt(1-s21^2)  s21;s21 sqrt(1-s21^2)]\nend\n\nfilter = EquationNetwork(2,50,sillyFilter)\n\namp = readTouchstone(\"Amp.s2p\")\n\nnet = cascade(amp,filter)\n\nax = plotRectangular(net,(2,1),label=\"Cascaded S(2,1)\")\nplotRectangular!(ax,amp,(2,1),label=\"Amplifier S(2,1)\")\nplotRectangular!(ax,filter,(2,1),freqs=net.frequency,label=\"Filter S(2,1)\")\nax[\"ylabel\"] = \"dB\"\nax # hide","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: Logo)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"\"Walks like Python, Runs like C\" for open source RF/Microwave engineering","category":"page"},{"location":"#Main-Features-1","page":"Home","title":"Main Features","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Marconi.jl is a library for analysis and plotting of linear RF/Microwave networks, antenna calculations, and rudimentary metamaterial calculations.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"It aims to give similar functionality as the wonderful scikit-rf library in pure Julia while extending the use case to some antennas and metamaterials.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"While focusing on linear network analysis now, we hope to implement some non-linear analysis as well as instrument control in the future.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The main crux of this library presently is on plotting as the Smith Chart plotting backend is in the heavyweight PGFPlotsX. The antenna plots are being written with the wonderful PlotlyJS backend such that once I finish writing the Plotly Smith Chart type, I can transition this entire library to have fully interactive, lightweight, portable plots.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\n    \"man/RFAnalysis.md\",\n    \"man/Plot.md\",\n    \"man/FileIO.md\",\n    \"man/NetworkAnalysis.md\",\n    \"man/Antennas.md\",\n    \"man/Metamaterials.md\"\n]\nDepth = 1","category":"page"},{"location":"#Library-Outline-1","page":"Home","title":"Library Outline","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"lib/Public.md\"]","category":"page"},{"location":"#Coming-Soon-1","page":"Home","title":"Coming Soon","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Depending on the progress of some other libraries, Marconi.jl would like to include in the near future","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Calibration\nInstrument control\nNoise analysis\nFilter builders\nSimple network construction from ideal components\nOptimization of said networks\nAdvanced calibration routines\nNon-linear analysis (X-Parameters, Load Pull, etc.)\nMore interactivity with plots","category":"page"},{"location":"#Using-Marconi.jl-1","page":"Home","title":"Using Marconi.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"To use Marconi.jl simply use the Pkg REPL","category":"page"},{"location":"#","page":"Home","title":"Home","text":"] add Marconi","category":"page"},{"location":"#","page":"Home","title":"Home","text":"or from Pkg itself","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using(Pkg)\nPkg.add(\"Marconi\")","category":"page"},{"location":"#In-Publications-1","page":"Home","title":"In Publications","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"If you use Marconi.jl in your work please cite us with something along the lines of","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Made possible with Marconi.jl, a Julia Library for DC to Daylight","category":"page"},{"location":"man/Plot/#Plotting-1","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"note: Note\nThe plotting library depends on a working installation of PGFPlotsX.jl","category":"page"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"Pages = [\"Plot.md\"]\nDepth = 3","category":"page"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"The core of the plotting functionality in Marconi comes from the PGFPlotsX backend. This library allows for publication-quality graphics with complete configurability of the layout itself.","category":"page"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"The functions within the plotting library merely contextualize the Network object or other parameters into a PGFPlotsX plot object.","category":"page"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"It is highly recommended to thoroughly read the docs for PGFPlotsX to make the post of its plotting capability.","category":"page"},{"location":"man/Plot/#Smith-Charts-1","page":"Plotting","title":"Smith Charts","text":"","category":"section"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"To start plotting on Smith Charts, it generally is a good idea to start with an empty SmithChart axis object from PGFPlotsX.","category":"page"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"cd(\"../../..\") # hide\ncp(\"examples/BPF.s2p\",\"docs/build/man/BPF.s2p\", force = true) # hide\ncp(\"examples/Amp.s2p\",\"docs/build/man/Amp.s2p\", force = true) # hide\nnothing","category":"page"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"using Marconi\nusing PGFPlotsX\nsc = SmithChart()","category":"page"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"This object is an Axis which can accept Plots objects as well as PGFPlotsX.Options.","category":"page"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"To push plot objects into this circle, one can use either plotSmithData! or plotSmithCircle!.","category":"page"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"These functions create a Plot object out of Network data and adds them to an existing Axis object.","category":"page"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"Lets add some data to this axis","category":"page"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"bpf = readTouchstone(\"BPF.s2p\")\nprint(bpf) # hide","category":"page"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"This is a network object of a BFCG-162W+ filter from MiniCircuits","category":"page"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"We can now simply call plotSmithData! to write this data to the chart. The third argument is a tuple of the parameter we want to plot. For this data, we want S(1,1), so we pass in the (1,1) tuple.","category":"page"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"plotSmithData!(sc,bpf,(1,1))","category":"page"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"This is the same behavior as if we constructed the axis and plotted simultaneously with plotSmithData.","category":"page"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"plotSmithData(bpf,(1,1))","category":"page"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"To add labels to any plot, we just call any of the plotting functions with the label kwarg.","category":"page"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"plotSmithData(bpf,(1,1),label=\"S(1,1)\")","category":"page"},{"location":"man/Plot/#Plotting-with-Equation-Driven-Networks-1","page":"Plotting","title":"Plotting with Equation-Driven Networks","text":"","category":"section"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"To plot with an EquationNetwork, we must also provide the frequencies to plot. This is done with the additional kwarg freqs. We can also pass in arguments to our functions with the args kwarg.","category":"page"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"function inductorAndResistor(L=1e-9,R=30;freq,Z0)\n    z = R + im*2*pi*freq*L\n    return (z-Z0)/(z+Z0)\nend\nRL = EquationNetwork(1,50,inductorAndResistor)\n\nax = plotSmithData(RL,(1,1),freqs=range(100e6,stop=10e9,length=201))\nplotSmithData!(ax,RL,(1,1),freqs=range(100e6,stop=10e9,length=201),args=(1e-9,50))","category":"page"},{"location":"man/Plot/#Smith-Chart-Circles-1","page":"Plotting","title":"Smith Chart Circles","text":"","category":"section"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"As anyone who has read Microwave Transistor Amplifiers would know, drawing circles on a Smith Chart could be very useful. In Marconi, use cases such as stability circles and gain circles are explored in RF Analysis.","category":"page"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"The plotSmithCircle! function behaves similarly to plotSmithData as it accepts a SmithChart object, x and y center coordinates, and a radius.","category":"page"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"These coordinates are referenced to the unit circle Gamma plane, so -1 leq x leq 1 and -1 leq y leq 1.","category":"page"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"This plot can also accept the opts kwarg.","category":"page"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"sc = SmithChart()\nstyle = @pgf {\"color\" = \"cyan\", \"very thick\"}\nplotSmithCircle!(sc,0.3,0.75,0.3,opts = style)","category":"page"},{"location":"man/Plot/#Plot-Options-1","page":"Plotting","title":"Plot Options","text":"","category":"section"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"As these plots and axes are fundamentally PGFPlotsX objects, we can pass in options using the opts kwarg. Additionally, the plotSmithData function can take a axopts kwarg to pass in options specific to the axis such as title and size.","category":"page"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"style = @pgf {color = \"red\", \"thick\"}\nsc = plotSmithData(bpf,(1,1),opts = style)","category":"page"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"The return of plotSmithData is a SmithChart axis object, so we can set variables after the fact as well just like every other PGFPlotsX object.","category":"page"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"sc[\"title\"] = \"My Smith Chart\"","category":"page"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"Finally, the width and tick mark density is all related as per the PGFPlots manual.","category":"page"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"Check it out here","category":"page"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"When creating a SmithChart axis by itself, there is no kwarg for options.","category":"page"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"using PGFPlotsX # hide\naxis_style = @pgf {width = \"15cm\",title = \"Medium Smith Chart\"}\nsc = SmithChart(axis_style)","category":"page"},{"location":"man/Plot/#Rectangular-Plots-1","page":"Plotting","title":"Rectangular Plots","text":"","category":"section"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"To plot on a rectangular axis, we call the plotRectangular and plotRectangular! functions.","category":"page"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"These operate similar in functionality to the smith chart plotting utilities as plotRectangular accepts a network object and the parameter to plot. Additionally, plotRectangular requires a function to apply to make 1-D data. This could be dB or dB20 for 20log10 as supplied by this library, real, imag, or some other function. Finally, one could plot any network parameter, be it S, Z, Y, or T.","category":"page"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"Same as plotSmithData, plotRectangular! accepts an opts kwarg as well as an axopts kwarg for plotRectangular as it is creating an axis object.","category":"page"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"using Marconi\nusing PGFPlotsX","category":"page"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"amp = readTouchstone(\"Amp.s2p\")\nax = plotRectangular(amp,(1,1),dB,label=\"S(1,1)\")\nplotRectangular!(ax,amp,(2,1),dB,label=\"S(2,1)\")\nax[\"ylabel\"] = \"dB\"\nax # hide","category":"page"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"Also, instead of supplying a tuple for the parameter to plot, one can supply a function to reduce a network to an array. There are several in this library for calculating stability, gain, and otherwise.","category":"page"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"plotRectangular(amp,testK,label=\"K Stabilty\")","category":"page"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"To apply another function, such as dB, real, or otherwise; supply that function after the network function.","category":"page"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"ax = plotRectangular(amp,testMSG,dB,label=\"MSG\")\nax[\"ylabel\"] = \"dB\"\nax # hide","category":"page"},{"location":"man/Plot/#Plotting-with-Equation-Driven-Networks-2","page":"Plotting","title":"Plotting with Equation-Driven Networks","text":"","category":"section"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"Plotting rectangular plots with equation-driven networks works much the same as plotting with smith charts. All of the other functionality for plotting is conserved as well of course.","category":"page"},{"location":"man/Plot/#","page":"Plotting","title":"Plotting","text":"function inductorAndResistor(L=1e-9,R=30;freq,Z0)\n    z = R + im*2*pi*freq*L\n    return (z-Z0)/(z+Z0)\nend\nRL = EquationNetwork(1,50,inductorAndResistor)\n\nax = plotRectangular(RL,(1,1),freqs=range(100e6,stop=10e9,length=201))\nplotRectangular!(ax,RL,(1,1),freqs=range(100e6,stop=10e9,length=201),args=(1e-9,50))","category":"page"}]
}
